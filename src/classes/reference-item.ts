import { timeout } from '../decorators';

/* eslint-disable no-underscore-dangle */
abstract class ReferenceItem { // зробили клас абстрактним, це дає те що де ми створювали екземпляри цього класу (завдання 5.1) вже працювати не буде
    // class ReferenceItem {
    // один варіант створення і ініціалізації властивостей

    // title: string;
    // year: number; // по замовчуванні пишемо що вони публічні, бо в завданні не вказано які мають бути
    // constructor(newTitle: string, newYear: number){
    //     console.log('Creating a new ReferenceItem...' );
    //     this.title = newTitle;// доступ до полів відбувається через this, таким чином ми ініціалізуємо властивості
    //     this.year = newYear;
    // }

    #id: number; // hard private властивість

    // другий варіант створення і ініціалізації властивостей
    // такий варіант дозволяє створити ті ж самі властивості, їх проініціалізувати
    constructor(
        id: number, // я не можу тут використати модифікатор, відповідно в нас не буде зразу створюватись властивість,
        // це тільки параметр,тому ми далі через this присвоюємо йому властивість щоб її ініціалізувати
        public title: string,// реалізація створення властивостей через параметри конструктора
        // якщо прибиремо чи public,чи private, чи... то властивість не створиться
        // ще можна додати readonly  наприклад public readonly title: string
        // назва параметру повинна співпадати з властивістю яку хочемо створити
        // private year: number
        protected year: number // змінили з приватної на протектед, щоб могли мати доступ в класі Encyclopedia
    // для нащадків доступне, а як публічне не рахується, скрито
    ){
        console.log('Creating a new ReferenceItem...' );
        this.#id =id;
    }

    getID(): number{ // публічний метод який повертає значення приватної властивості id
        return this.#id;
    }


    private _publisher: string; // приватна (“soft private”) рядкова властивість _publisher

    get publisher(): string { // це йде реалізація властивості, коли пізніше ми викликаємо і присвоюємо щось то під капотом викликається setter чи getter функція
        // геттер який перетворює властивість _publisher у верхній регістр і повертає його
        return this._publisher.toUpperCase(); // має доступ до this (контексту)
        // з'явилась помилка в еслінті Unexpected dangling '_' in '_publisher'. тому ми закоментували це правило в еслінті ми це вказали через квік фікс і це додалось на початок поточного файлу
    }

    set publisher(newPublisher: string) { // зазвичай має один параметр
        this._publisher = newPublisher; // встановлює значення властивості _publisher в значення параметра newPublisher
    }

    // в даному випадку гетер і сетер є публічними

    static department: string = 'Research Dep.'; // ми створили статичну рядкову властивість department
    // і проініціалізуйте її значенням за замовчуванням

    @timeout(2000)
    printItem(): void { // метод робимо публічним, бо не вказано який має бути
        console.log(`${this.title} was published in ${this.year}`);
        // тут ми явно вказали клас
        console.log(ReferenceItem.department); // якщо нам потрібно вивести статичну властивість то беремо назву класу і назву властивості
        // і потім виведеться Research Dep. в консоль
        // console.log(Object.getPrototypeOf(this).constructor.name);// пробуємо дістатись до конструктора прототипу (а це буде клас) і потім дістатися до статики
        // далі береко констурктор( це є метод, тому там є властивість name) і таким чином виводимо рядок який буде представляти назву цього класу

        // а тут не вказували клас, ми отримали результат на основі посилання на об'єкт .Результат той самий
        console.log(Object.getPrototypeOf(this).constructor.department); // якщо візмемо department замість name то в консолі буде значення нашрї стативної властивості
    }

    abstract printCitation(): void; // абстрактний метод printCitation(), який не приймає параметрів і не повертає значення. Цей метод має бути без реалізації
    // тому що в базовому абстрактому класі ми не реалізуємо абстрактий метод чи властивість, робимо це в нащадках
    // абстрактний метод заставляє в нащадків реалізовувати всі абстрачні методи і властивості
}


export {ReferenceItem};